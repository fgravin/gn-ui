/**
 * DataFeeder API
 * This API covers dataset upload and publishing features of the application
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: psc@georchestra.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
} from '@angular/common/http'
import { CustomHttpParameterCodec } from '../encoder'
import { Observable } from 'rxjs'

import { BoundingBoxApiModel } from '../model/models'
import { UploadJobStatusApiModel } from '../model/models'

import { BASE_PATH, COLLECTION_FORMATS } from '../variables'
import { Configuration } from '../configuration'

@Injectable({
  providedIn: 'root',
})
export class FileUploadApiService {
  protected basePath = 'https://localhost:8080'
  public defaultHeaders = new HttpHeaders()
  public configuration = new Configuration()
  public encoder: HttpParameterCodec

  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string,
    @Optional() configuration: Configuration
  ) {
    if (configuration) {
      this.configuration = configuration
    }
    if (typeof this.configuration.basePath !== 'string') {
      if (typeof basePath !== 'string') {
        basePath = this.basePath
      }
      this.configuration.basePath = basePath
    }
    this.encoder = this.configuration.encoder || new CustomHttpParameterCodec()
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data'
    for (const consume of consumes) {
      if (form === consume) {
        return true
      }
    }
    return false
  }

  private addToHttpParams(
    httpParams: HttpParams,
    value: any,
    key?: string
  ): HttpParams {
    if (typeof value === 'object' && value instanceof Date === false) {
      httpParams = this.addToHttpParamsRecursive(httpParams, value)
    } else {
      httpParams = this.addToHttpParamsRecursive(httpParams, value, key)
    }
    return httpParams
  }

  private addToHttpParamsRecursive(
    httpParams: HttpParams,
    value?: any,
    key?: string
  ): HttpParams {
    if (value == null) {
      return httpParams
    }

    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        ;(value as any[]).forEach(
          (elem) =>
            (httpParams = this.addToHttpParamsRecursive(httpParams, elem, key))
        )
      } else if (value instanceof Date) {
        if (key != null) {
          httpParams = httpParams.append(
            key,
            (value as Date).toISOString().substr(0, 10)
          )
        } else {
          throw Error('key may not be null if value is Date')
        }
      } else {
        Object.keys(value).forEach(
          (k) =>
            (httpParams = this.addToHttpParamsRecursive(
              httpParams,
              value[k],
              key != null ? `${key}.${k}` : k
            ))
        )
      }
    } else if (key != null) {
      httpParams = httpParams.append(key, value)
    } else {
      throw Error('key may not be null if value is not object or array')
    }
    return httpParams
  }

  /**
   * Poll the status of all the upload jobs. Access restricted to administrators
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findAllUploadJobs(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<UploadJobStatusApiModel>>
  public findAllUploadJobs(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<UploadJobStatusApiModel>>>
  public findAllUploadJobs(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<UploadJobStatusApiModel>>>
  public findAllUploadJobs(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(
        httpHeaderAccepts
      )
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType = 'text'
    }

    return this.httpClient.get<Array<UploadJobStatusApiModel>>(
      `${this.configuration.basePath}/upload/all`,
      {
        responseType: <any>responseType,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Poll the status of a given upload job by id
   * @param jobId Unique job identifier
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findUploadJob(
    jobId: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<UploadJobStatusApiModel>
  public findUploadJob(
    jobId: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<UploadJobStatusApiModel>>
  public findUploadJob(
    jobId: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<UploadJobStatusApiModel>>
  public findUploadJob(
    jobId: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (jobId === null || jobId === undefined) {
      throw new Error(
        'Required parameter jobId was null or undefined when calling findUploadJob.'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(
        httpHeaderAccepts
      )
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType = 'text'
    }

    return this.httpClient.get<UploadJobStatusApiModel>(
      `${this.configuration.basePath}/upload/${encodeURIComponent(
        String(jobId)
      )}`,
      {
        responseType: <any>responseType,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Poll the status of all the upload jobs owned by the calling user
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public findUserUploadJobs(
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<Array<UploadJobStatusApiModel>>
  public findUserUploadJobs(
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<Array<UploadJobStatusApiModel>>>
  public findUserUploadJobs(
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<Array<UploadJobStatusApiModel>>>
  public findUserUploadJobs(
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(
        httpHeaderAccepts
      )
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType = 'text'
    }

    return this.httpClient.get<Array<UploadJobStatusApiModel>>(
      `${this.configuration.basePath}/upload`,
      {
        responseType: <any>responseType,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Get the bounding box of the dataset, optionally indicating the CRS and whether to reproject from the native CRS to the new one The returned geometry CRS is controlled by the \&quot;srs\&quot;, and \&quot;srsOverride\&quot; query parameters. If none is provided, the geometry is returned as-is, in the dataset\&#39;s native CRS (possibly null). The \&quot;srsOverride\&quot; parameter allows to override the dataset\&#39;s native CRS, which also means assuming a native CRS when the dataset didn\&#39;t provide a native CRS (e.g. a shapefile uploaded without .prj side-car file). The \&quot;srs\&quot; parameter specifies the output geometry CRS. The geometry will be reprojected from the source CRS to the output CRS.
   * @param jobId Unique job identifier
   * @param typeName Feature type name
   * @param srs Optional, output coordinate reference system (e.g. \&#39;EPSG:3857\&#39;)
   * @param srsOverride Optional, EPSG SRS used to override the native CRS, or assume a native SRS when the native CRS is unknown (for example, a shapefile uploaded without .prj side-car file). This allows to request the dataset bounds using a user defined native CRS for datasets that do not specify a native CRS, and still get a reprojected response to another CRS in combination with the \&quot;srs\&quot; parameter.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getBounds(
    jobId: string,
    typeName: string,
    srs?: string,
    srsOverride?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<BoundingBoxApiModel>
  public getBounds(
    jobId: string,
    typeName: string,
    srs?: string,
    srsOverride?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<BoundingBoxApiModel>>
  public getBounds(
    jobId: string,
    typeName: string,
    srs?: string,
    srsOverride?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<BoundingBoxApiModel>>
  public getBounds(
    jobId: string,
    typeName: string,
    srs?: string,
    srsOverride?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    if (jobId === null || jobId === undefined) {
      throw new Error(
        'Required parameter jobId was null or undefined when calling getBounds.'
      )
    }
    if (typeName === null || typeName === undefined) {
      throw new Error(
        'Required parameter typeName was null or undefined when calling getBounds.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (srs !== undefined && srs !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>srs, 'srs')
    }
    if (srsOverride !== undefined && srsOverride !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>srsOverride,
        'srsOverride'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(
        httpHeaderAccepts
      )
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType = 'text'
    }

    return this.httpClient.get<BoundingBoxApiModel>(
      `${this.configuration.basePath}/upload/${encodeURIComponent(
        String(jobId)
      )}/${encodeURIComponent(String(typeName))}/bounds`,
      {
        params: queryParameters,
        responseType: <any>responseType,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Obtain a sample dataset feature in GeoJSON format, optionally specifying a feature index, crs, and/or dataset\&#39;s character encoding. The response encoding is always UTF-8. The \&#39;encoding\&#39; parameter can be used to force reading the native data in a different charset. The returned geometry CRS is controlled by the \&quot;srs\&quot;, and \&quot;srsOverride\&quot; query parameters. If none is provided, the geometry is returned as-is, in the dataset\&#39;s native CRS (possibly null). The \&quot;srsOverride\&quot; parameter allows to override the dataset\&#39;s native CRS, which also means assuming a native CRS when the dataset didn\&#39;t provide a native CRS (e.g. a shapefile uploaded without .prj side-car file). The \&quot;srs\&quot; parameter specifies the output geometry CRS. The geometry will be reprojected from the source CRS to the output CRS.
   * @param jobId Unique job identifier
   * @param typeName Feature type name
   * @param featureIndex Optional feature index, if unspecified, the first feature (index 0) is returned
   * @param encoding Optional, force dataset encoding
   * @param srs Optional, coordinate reference system (e.g. \&#39;EPSG:3857\&#39;)
   * @param srsOverride Optional, EPSG SRS used to override the native CRS, or assume a native SRS when the native CRS is unknown (for example, a shapefile uploaded without .prj side-car file). This allows to request a feature using a source CRS for datasets that do not specify a native CRS, and still get a reprojected response to another CRS in combination with the \&quot;srs\&quot; parameter.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public getSampleFeature(
    jobId: string,
    typeName: string,
    featureIndex?: number,
    encoding?: string,
    srs?: string,
    srsOverride?: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/geo+json' }
  ): Observable<object>
  public getSampleFeature(
    jobId: string,
    typeName: string,
    featureIndex?: number,
    encoding?: string,
    srs?: string,
    srsOverride?: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/geo+json' }
  ): Observable<HttpResponse<object>>
  public getSampleFeature(
    jobId: string,
    typeName: string,
    featureIndex?: number,
    encoding?: string,
    srs?: string,
    srsOverride?: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/geo+json' }
  ): Observable<HttpEvent<object>>
  public getSampleFeature(
    jobId: string,
    typeName: string,
    featureIndex?: number,
    encoding?: string,
    srs?: string,
    srsOverride?: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/geo+json' }
  ): Observable<any> {
    if (jobId === null || jobId === undefined) {
      throw new Error(
        'Required parameter jobId was null or undefined when calling getSampleFeature.'
      )
    }
    if (typeName === null || typeName === undefined) {
      throw new Error(
        'Required parameter typeName was null or undefined when calling getSampleFeature.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (featureIndex !== undefined && featureIndex !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>featureIndex,
        'featureIndex'
      )
    }
    if (encoding !== undefined && encoding !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>encoding,
        'encoding'
      )
    }
    if (srs !== undefined && srs !== null) {
      queryParameters = this.addToHttpParams(queryParameters, <any>srs, 'srs')
    }
    if (srsOverride !== undefined && srsOverride !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>srsOverride,
        'srsOverride'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/geo+json']
      httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(
        httpHeaderAccepts
      )
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType = 'text'
    }

    return this.httpClient.get<object>(
      `${this.configuration.basePath}/upload/${encodeURIComponent(
        String(jobId)
      )}/${encodeURIComponent(String(typeName))}/sampleFeature`,
      {
        params: queryParameters,
        responseType: <any>responseType,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Remove a job and all its resources (e.g. temporary files). Does not unpublish. Use abort&#x3D;true to abort a running analysis or publishing job
   * @param jobId Unique job identifier
   * @param abort If true, abort the dataset analysis or publishing, if running. Defaults to false
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public removeJob(
    jobId: string,
    abort?: boolean,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined }
  ): Observable<any>
  public removeJob(
    jobId: string,
    abort?: boolean,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined }
  ): Observable<HttpResponse<any>>
  public removeJob(
    jobId: string,
    abort?: boolean,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: undefined }
  ): Observable<HttpEvent<any>>
  public removeJob(
    jobId: string,
    abort?: boolean,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: undefined }
  ): Observable<any> {
    if (jobId === null || jobId === undefined) {
      throw new Error(
        'Required parameter jobId was null or undefined when calling removeJob.'
      )
    }

    let queryParameters = new HttpParams({ encoder: this.encoder })
    if (abort !== undefined && abort !== null) {
      queryParameters = this.addToHttpParams(
        queryParameters,
        <any>abort,
        'abort'
      )
    }

    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = []
      httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(
        httpHeaderAccepts
      )
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    let responseType: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType = 'text'
    }

    return this.httpClient.delete<any>(
      `${this.configuration.basePath}/upload/${encodeURIComponent(
        String(jobId)
      )}`,
      {
        params: queryParameters,
        responseType: <any>responseType,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }

  /**
   * Upload one or multiple files to the server, and get a handle to the job. Once the files are uploaded, the analysis process is automatically triggered. Its status can be polled with GET /upload/{jobId}
   * @param filename
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public uploadFiles(
    filename?: Array<Blob>,
    observe?: 'body',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<UploadJobStatusApiModel>
  public uploadFiles(
    filename?: Array<Blob>,
    observe?: 'response',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpResponse<UploadJobStatusApiModel>>
  public uploadFiles(
    filename?: Array<Blob>,
    observe?: 'events',
    reportProgress?: boolean,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<HttpEvent<UploadJobStatusApiModel>>
  public uploadFiles(
    filename?: Array<Blob>,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: { httpHeaderAccept?: 'application/json' }
  ): Observable<any> {
    let headers = this.defaultHeaders

    let httpHeaderAcceptSelected: string | undefined =
      options && options.httpHeaderAccept
    if (httpHeaderAcceptSelected === undefined) {
      // to determine the Accept header
      const httpHeaderAccepts: string[] = ['application/json']
      httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(
        httpHeaderAccepts
      )
    }
    if (httpHeaderAcceptSelected !== undefined) {
      headers = headers.set('Accept', httpHeaderAcceptSelected)
    }

    // to determine the Content-Type header
    const consumes: string[] = ['multipart/form-data']

    const canConsumeForm = this.canConsumeForm(consumes)

    let formParams: { append(param: string, value: any): any }
    let useForm = false
    let convertFormParamsToString = false
    // use FormData to transmit files using content-type "multipart/form-data"
    // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
    useForm = canConsumeForm
    if (useForm) {
      formParams = new FormData()
    } else {
      formParams = new HttpParams({ encoder: this.encoder })
    }

    if (filename) {
      if (useForm) {
        filename.forEach((element) => {
          formParams =
            (formParams.append('filename', <any>element) as any) || formParams
        })
      } else {
        formParams =
          (formParams.append(
            'filename',
            filename.join(COLLECTION_FORMATS['csv'])
          ) as any) || formParams
      }
    }

    let responseType: 'text' | 'json' = 'json'
    if (
      httpHeaderAcceptSelected &&
      httpHeaderAcceptSelected.startsWith('text')
    ) {
      responseType = 'text'
    }

    return this.httpClient.post<UploadJobStatusApiModel>(
      `${this.configuration.basePath}/upload`,
      convertFormParamsToString ? formParams.toString() : formParams,
      {
        responseType: <any>responseType,
        withCredentials: this.configuration.withCredentials,
        headers: headers,
        observe: observe,
        reportProgress: reportProgress,
      }
    )
  }
}
